<!DOCTYPE html>
<html>
  <head>
    <title>United States</title>
    <style>
      #map,
      #range {
        position: absolute;
      }
      #range {
        z-index: 1;
      }
      header {
        font-size: 35px;
        font-weight: bold;
      }
      header img {
        vertical-align: bottom;
      }
      #fontSizeInput {
        width: 35px;
      }
    </style>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  </head>
  <body>
    <header>
	United States Dynamic Zombie Pathing
	<img src="" />
        <span id="invalidText" style="color: red; font-style: italic; font-size: 20px;"></span>
    </header>
<div>
  <button id="zoomInButton"><i class="fas fa-search-plus"></i></button>
  <button id="blizzardButton" onclick="button_AddBlizzards()">Add Blizzards</button>
  <button id="eraserButton" onclick="eraser()">Eraser</button>
  <label for="fontSizeInput">Font Size:</label>
  <input type="number" id="fontSizeInput" name="fontSizeInput" value="30" min="1" max="100">
  <button id="stopButton" onclick="button_StopEditing()">Stop Editing</button>
</div>
<div>
  <button id="zoomOutButton"><i class="fas fa-search-minus"></i></button>
  <button id="portalButton" onclick="button_AddPortals()">Add Portals</button>
  <button id="undoButton" onclick="button_Undo()">Undo</button>
  <button id="resetButton">Reset Map</button>
  <a href="https://ares-thefox.github.io/Risk-Dynamic-Zombie-Pathing" target="_blank">
    <button id="mapDirectoryButton">Map Directory</button>
  </a>
</div>
	<style>
	/* Add some basic styles to the button */
	button {
	font-size: 16px;
	padding: 8px 16px;
	border: none;
	cursor: pointer;
	}

	#blizzardButton {
	width: 180px;
	text-align: center;
	background-color: white;
	color: black;
	}

	#blizzardButton:hover {
	background-color: grey;
	}

	#portalButton {
	width: 180px;
	text-align: center;
	background-color: aqua;
	color: black;
	}

	#portalButton:hover {
	background-color: navy;
	color: white;
	}

	#eraserButton {
	width: 80px;
	text-align: center;
	background-color: #dd9d90;
	color: black;
	}

	#eraserButton:hover {
	background-color: #c89790;
	}
		
	#stopButton {
	background-color: white;
	color: white;
	}

	#stopButton:hover {
	background-color: white;
	}
		
	#undoButton {
	width: 80px;
	text-align: center;
	background-color: #d8482e;
	color: black;
	}

	#undoButton:hover {
	background-color: #c13e27;
	}

	#resetButton {
	width: 112px;
	text-align: center;
	background-color: grey;
	color: white;
	}

	#resetButton:hover {
	background-color: black;
	color: white;
	}

	#mapDirectoryButton {
	background-color: white;
	color: black;
	}

	#mapDirectoryButton:hover {
	background-color: grey;
	}
		
	#zoomInButton:hover {
	background-color: #ababab;
	}
		
	#zoomOutButton:hover {
	background-color: #ababab;
	}
	</style>
	  
    <img
      id="map"
      src="https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/United%20States.PNG"
      alt="United States"
    />
    <div id="range"></div>
	  
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script>
<script>
  let zoom = 1;
  document.getElementById("zoomInButton").addEventListener("click", function () {
    zoom += 0.1;
    document.body.style.zoom = zoom;
  });
  document.getElementById("zoomOutButton").addEventListener("click", function () {
    zoom -= 0.1;
    document.body.style.zoom = zoom;
  });
	
  document.getElementById("resetButton").addEventListener("click", function () {
    location.reload();
  });

var images = [
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox1.PNG",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox2.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox3.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox4.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox5.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox6.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox7.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox8.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox9.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox10.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox11.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox12.png"
];

window.onload = function() {
  var img = document.querySelector("header img");
  var randomIndex = Math.floor(Math.random() * images.length);
  img.src = images[randomIndex];
};

// Define global variables
console.log("23453245")

	// Define map-specific items
	var ZombieFile = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Zombie-Pathing/main/United%20States%20Zombie%20File.csv"
	var SVG = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Zombie-Pathing/main/United%20States%20Paths.svg"
	// Remember to change the img src and the alt title!!!!!!!!

	var totalBlizzards = 3
	var totalPortals = 5
	
	let blizzardArray = []
	let portalArray = []
	let clickedPathsBlizzardsPortals = []
	
	// Define connections tableData
	let tableData;
	let tableDataClone;
	Papa.parse(
	  ZombieFile,
	  {
	    download: true,
	    header: true,
	    complete: function (results) {
	      // Assign parsed data to tableData
	      tableData = results.data;
	      // Remove zero-width space character from tableData
	      for (let i = 0; i < tableData.length; i++) {
		for (let key in tableData[i]) {
		  if (tableData[i].hasOwnProperty(key)) {
		    tableData[i][key] = tableData[i][key].replace(/\u200B/g, "");
		  }
		}
	      }
	      // Create a deep copy of tableData
	      tableDataClone = JSON.parse(JSON.stringify(tableData));
	    },
	  }
	);
	
	// Define color dictionaries 
	const colorDictionary = {
	  1: "#ff0000",
	  2: "#18c500",
	  3: "#006cff",
	  4: "#ffff00",
	  5: "#ffffff",
	  6: "#000000",
	  7: "#000000",
	  8: "#000000",
	  9: "#000000",
	 10: "#000000"
	};
	
// End of global variables

// Load the SVG
let paths;
let svgElement;
let newSVG; // Define newSVG with let keyword at the start
var xhr = new XMLHttpRequest();
xhr.open(
  "GET",
  SVG
);
xhr.onload = function () {
  if (xhr.status === 200) {
    var svg = xhr.responseText;
    var rangeElement = document.getElementById("range");
    rangeElement.innerHTML = svg;
    svgElement = rangeElement.querySelector("svg");
    paths = svgElement.querySelectorAll("path");
    paths.forEach(function (path) {
      path.setAttribute("fill", "transparent");
      path.setAttribute("stroke-opacity", "0");
    });

    // Define new SVG as a local variable
    newSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    
    // Get the dimensions of the image element with id="map"
    let mapImg = document.getElementById("map");
    newSVG.setAttribute("width", mapImg.naturalWidth);
    newSVG.setAttribute("height", mapImg.naturalHeight);
    
    // Set CSS properties to position newSVG on top of svgElement
    svgElement.style.position = "absolute";
    newSVG.style.position = "absolute";
    newSVG.style.zIndex = "1";
    newSVG.style.pointerEvents = "none";
    
    // Add the newSVG to the range element
    rangeElement.appendChild(newSVG);
  }
};
xhr.send();


	

// Stop editing
function stopEditing() {
	document.getElementById("stopButton").innerHTML = "Stop Editing";
	// Set the regular background color to white
	document.getElementById("stopButton").style.backgroundColor = "white";
	// Set the hover background color to white
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: white !important; }";
	document.head.appendChild(styleElement);
	return;
}




	

// Define marker for arrowhead
let marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
marker.setAttribute("id", "arrow");
marker.setAttribute("markerWidth", "10");
marker.setAttribute("markerHeight", "10");
marker.setAttribute("refX", "0");
marker.setAttribute("refY", "3");
marker.setAttribute("orient", "auto");
marker.setAttribute("markerUnits", "strokeWidth");

// Create path for arrowhead
let arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
arrowPath.setAttribute("d", "M0,0 L0,6 L9,3 z");
arrowPath.setAttribute("fill", "#f00");

// Append arrowPath to marker and marker to newSVG
marker.appendChild(arrowPath);
newSVG.appendChild(marker);


	
// Generate the map
function generateMap() {
  // Update buttons
  updateButtonText();
  // Reset tableData to its original values
  tableData = JSON.parse(JSON.stringify(tableDataClone));
  // Remove everything contained in the blizzard array
	// Find rows in table data where column A matches values in blizzardArray
	const rows = tableData.filter((row) => blizzardArray.includes(row["Territory"]));

	// Remove everything in column B for those rows
	rows.forEach((row) => {
	  row["Connections"] = "";
	});

	// Remove all instances of values in blizzardArray from column B
	tableData.forEach((row) => {
	  if (row["Connections"]) {
	    // Split the value in column B into an array of values
	    let values = row["Connections"].split(",");
	    // Filter out any values that are included in the blizzardArray
	    values = values.filter((value) => !blizzardArray.includes(value));
	    // Join the remaining values back into a string and update the value in column B
	    row["Connections"] = values.join(",");
	  }
	});
  // Calculate O
  tableData.forEach((row) => {
    if (row["Connections"] && row["Connections"].trim() !== "") {
      // check if column B is not empty or undefined
      const values = row["Connections"].split(",");
      row["O"] = values.length;
    } else {
      row["O"] = 0;
    }
  })
// Calculate offsets
let locationDict = {};
let extraLocationDict = {};
tableData.forEach((row) => {
  locationDict[row["Territory"]] = [
    parseInt(row["Pixel Pair 1"]),
    parseInt(row["Pixel Pair 2"]),
  ];
  if (
    row["Extra 1"] &&
    row["Extra 2"] &&
    row["Connection"]
  ) {
    extraLocationDict[[row["Territory"], row["Connection"]]] = [
      parseInt(row["Extra 1"]),
      parseInt(row["Extra 2"]),
    ];
  }
});

// Count the number of lines between each pair of nodes
let lineCounts = {};
tableData.forEach((row) => {
  let startLocation = locationDict[row["Territory"]];
  let connectionsList = row["Connections"].split(",");
  connectionsList.forEach((col, j) => {
    let endLocation = locationDict[col];
    let pair = [row["Territory"], col].sort();
    if (!lineCounts[pair]) {
      lineCounts[pair] = 0;
    }
    lineCounts[pair]++;
  });
});

// Function to calculate a point offset from the start or end point
function offsetPoint(start, end, offset) {
  let angle = Math.atan2(start[1] - end[1], start[0] - end[0]);
  let x = end[0] + offset * Math.cos(angle);
  let y = end[1] + offset * Math.sin(angle);
  return [x, y];
}

// Function to calculate a point offset perpendicular to the line between two points
function perpendicularOffsetPoint(point, angle, offset) {
  let x = point[0] + offset * Math.cos(angle);
  let y = point[1] + offset * Math.sin(angle);
  return [x, y];
}

// Add a new dictionary to keep track of lines that have already been drawn
let drawnLines = {};

// Draw the arrows
let lineIndex = {};
tableData.forEach((row) => {
  let startLocation = locationDict[row["Territory"]];
  let connectionsList = row["Connections"].split(",");
  connectionsList.forEach((col, j) => {
    let endLocation;
    if (extraLocationDict[[row["Territory"], col]]) {
      endLocation = extraLocationDict[[row["Territory"], col]];
    } else {
      endLocation = locationDict[col];
    }
    let pair = [row["Territory"], col].sort();
    if (!lineIndex[pair]) {
      lineIndex[pair] = 0;
    }
    let nLines = lineCounts[pair];
    let indexOffset = 5 * (lineIndex[pair] - Math.floor(nLines / 2));
    if (nLines % 2 === 0) {
      indexOffset += indexOffset > 0 ? 5 / 2 : -5 / 2;
    }
    lineIndex[pair]++;
    let angle =
      Math.atan2(
        startLocation[1] - endLocation[1],
        startLocation[0] - endLocation[0]
      ) +
      Math.PI / 2;

	// Check if a line has already been drawn between this pair of territories
	if (drawnLines[pair] && drawnLines[pair]["color"] === colorDictionary[j + 1]) {
	  // Add arrowheads to both ends of the existing line
	  let existingArrowPathStart = document.createElementNS(
	    "http://www.w3.org/2000/svg",
	    "path"
	  );
	  existingArrowPathStart.setAttribute(
	    "d",
	    `M${drawnLines[pair]["end"][0]},${drawnLines[pair]["end"][1]} L${
	      drawnLines[pair]["start"][0]
	    },${drawnLines[pair]["start"][1]}`
	  );
	  existingArrowPathStart.setAttribute("stroke", colorDictionary[j + 1]);
	  existingArrowPathStart.setAttribute("stroke-width", "3");
	  existingArrowPathStart.setAttribute("marker-end", "url(#arrow)");
	
	  // Append the arrow path to the newSVG
	  newSVG.appendChild(existingArrowPathStart);
	} else {
	  // Draw a new line and add it to the drawnLines dictionary
	  let offsetStartLocation = perpendicularOffsetPoint(
	    offsetPoint(endLocation, startLocation, 15),
	    angle,
	    indexOffset
	  );
	  let offsetEndLocation = perpendicularOffsetPoint(
	    offsetPoint(startLocation, endLocation, 15),
	    angle,
	    indexOffset
	  );
	
	  // Create a new path element for the arrow
	  let arrowPath = document.createElementNS(
	    "http://www.w3.org/2000/svg",
	    "path"
	  );
	  arrowPath.setAttribute(
	    "d",
	    `M${offsetStartLocation[0]},${offsetStartLocation[1]} L${offsetEndLocation[0]},${offsetEndLocation[1]}`
	  );
	  arrowPath.setAttribute("stroke", colorDictionary[j + 1]);
	  arrowPath.setAttribute("stroke-width", "3");
	  arrowPath.setAttribute("marker-end", "url(#arrow)");
	
	  // Append the arrow path to the newSVG
	  newSVG.appendChild(arrowPath);
	
	  // Add the new line to the drawnLines dictionary
	  drawnLines[pair] = {
	    start: offsetStartLocation,
	    end: offsetEndLocation,
	    color: colorDictionary[j + 1],
	  };
	}
  });
});

// Add the newSVG to the range element
rangeElement.appendChild(newSVG);

// Bring the old SVG to front
rangeElement.removeChild(svgElement);
rangeElement.appendChild(svgElement);
}
  
	
function debounce(func, wait) {
  let timeout;
  return function() {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, arguments), wait);
  };
}

const debouncedGenerateMap = debounce(generateMap, 500);

function addPortals() {
  let shouldReturn = false;
  document.getElementById("stopButton").innerHTML = "Stop Adding Portals";
	// Set the regular background color to green
	document.getElementById("stopButton").style.backgroundColor = "#4caf50";
	// Set the hover background color to dark green
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: #3e8e41 !important; }";
	document.head.appendChild(styleElement);

  const blizzardButtonClick = function () {
    shouldReturn = true;
  };
  const portalButtonClick = function () {
    shouldReturn = true;
  };
  const eraserButtonClick = function () {
    shouldReturn = true;
  };
  const stopButtonClick = function () {
    shouldReturn = true;
  };
	
  document.getElementById("blizzardButton").addEventListener("click", blizzardButtonClick);
  document.getElementById("portalButton").addEventListener("click", portalButtonClick);
  document.getElementById("eraserButton").addEventListener("click", eraserButtonClick);
  document.getElementById("stopButton").addEventListener("click", stopButtonClick);

  // Check if size of portalArray is greater than or equal to totalPortals
  if (portalArray.length >= totalPortals) {
    // Return early from the function
    return;
  }
	// Define mouseover, mouseout, and click event handlers
	const mouseoverHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Change stroke color to white and stroke width to 3
	    this.style.setProperty("stroke", "white", "important");
	    this.style.setProperty("stroke-width", "3", "important");
	  }
	};
	const mouseoutHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Reset stroke color
	    let border_color = colorDarktionary[value];
	    this.style.setProperty("fill", "transparent", "important");
	  }
	};
  const clickHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is NOT in clickedPathsBlizzardsPortals array
    if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	// Create an image element and set its attributes
	var image = document.createElementNS(
	  "http://www.w3.org/2000/svg",
	  "image"
	);
	image.setAttributeNS(
	  "http://www.w3.org/1999/xlink",
	  "href",
	  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/portal.png"
	);

	// Set a custom attribute to store the id of the clicked path
	image.setAttribute("data-path-id", this.id);

	// Store the value of this.id in a variable
	var pathId = this.id;

	// Find matching row in CSV data
	var tableRow = tableData.find(function (row) {
	  return row["Territory"] === pathId;
	});

      // Get coordinates from CSV data
      var x = tableRow["Pixel Pair 1"];
      var y = tableRow["Pixel Pair 2"];

      // Set pointer-events attribute of the image element to none
      image.setAttribute("pointer-events", "none");

      // Append the image to the SVG
      svgElement.appendChild(image);

      // Add an event listener to the image element to update its x and y attributes after it has been loaded
      image.addEventListener("load", function() {
        // Get the bounding box of the image element
        var bbox = image.getBBox();

        // Update the x and y attributes of the image element to center it over the clicked area
        image.setAttribute("x", x - bbox.width / 2);
        image.setAttribute("y", y - bbox.height / 2);

        // Rotate the image a random number of degrees between 0 and 359 around its center point
        var angle = Math.floor(Math.random() * 360);
        var cx = x;
        var cy = y;
        image.setAttribute(
          "transform",
          "rotate(" + angle + " " + cx + " " + cy + ")"
        );
      });

      // Add clicked path to arrays; push to history
      portalArray.push(this.id);
      clickedPathsBlizzardsPortals.push(this.id);
      history.push({ type: 'addPortal', pathId: this.id });

       // Check if size of blizzardArray is greater than or equal to totalBlizzards
       if (portalArray.length >= totalPortals) {
         // Remove existing event listeners from elements in paths array
         paths.forEach(function (path) {
           path.removeEventListener("mouseover", mouseoverHandler);
           path.removeEventListener("mouseout", mouseoutHandler);
           path.removeEventListener("click", clickHandler);
         });
     	       document.getElementById("stopButton").innerHTML = "Stop Editing";
		// Set the regular background color to white
		document.getElementById("stopButton").style.backgroundColor = "white";
		// Set the hover background color to white
		var styleElement = document.createElement("style");
		styleElement.id = "stopButtonHoverStyle";
		styleElement.textContent = "#stopButton:hover { background-color: white !important; }";
		document.head.appendChild(styleElement);

	       generateMap();
	       return;
       }

       // Execute generateMap function
       generateMap();
    }
  };

  // Add event listeners to elements in paths array
  paths.forEach(function (path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
    path.addEventListener("click", clickHandler);
  });
}

function addBlizzards() {
  let shouldReturn = false;
  document.getElementById("stopButton").innerHTML = "Stop Adding Blizzards";
	// Set the regular background color to green
	document.getElementById("stopButton").style.backgroundColor = "#4caf50";
	// Set the hover background color to dark green
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: #3e8e41 !important; }";
	document.head.appendChild(styleElement);

  const blizzardButtonClick = function () {
    shouldReturn = true;
  };
  const portalButtonClick = function () {
    shouldReturn = true;
  };
  const eraserButtonClick = function () {
    shouldReturn = true;
  };
  const stopButtonClick = function () {
    shouldReturn = true;
  };
	
  document.getElementById("blizzardButton").addEventListener("click", blizzardButtonClick);
  document.getElementById("portalButton").addEventListener("click", portalButtonClick);
  document.getElementById("eraserButton").addEventListener("click", eraserButtonClick);
  document.getElementById("stopButton").addEventListener("click", stopButtonClick);

  // Check if size of portalArray is greater than or equal to totalPortals
  if (blizzardArray.length >= totalBlizzards) {
    // Return early from the function
    return;
  }
	// Define mouseover, mouseout, and click event handlers
	const mouseoverHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Change stroke color to white and stroke width to 3
	    this.style.setProperty("stroke", "white", "important");
	    this.style.setProperty("stroke-width", "3", "important");
	  }
	};
	const mouseoutHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Reset stroke color
	    this.style.setProperty("fill", "transparent", "important");
	  }
	};
  const clickHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is NOT in clickedPathsBlizzardsPortals array
    if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	// Create an image element and set its attributes
	var image = document.createElementNS(
	  "http://www.w3.org/2000/svg",
	  "image"
	);
	image.setAttributeNS(
	  "http://www.w3.org/1999/xlink",
	  "href",
	  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/snowflake.png"
	);

	// Set a custom attribute to store the id of the clicked path
	image.setAttribute("data-path-id", this.id);

	// Store the value of this.id in a variable
	var pathId = this.id;

	// Find matching row in CSV data
	var tableRow = tableData.find(function (row) {
	  return row["Territory"] === pathId;
	});

      // Get coordinates from CSV data
      var x = tableRow["Pixel Pair 1"];
      var y = tableRow["Pixel Pair 2"];

      // Set pointer-events attribute of the image element to none
      image.setAttribute("pointer-events", "none");

      // Append the image to the SVG
      svgElement.appendChild(image);

      // Add an event listener to the image element to update its x and y attributes after it has been loaded
      image.addEventListener("load", function() {
        // Get the bounding box of the image element
        var bbox = image.getBBox();

        // Update the x and y attributes of the image element to center it over the clicked area
        image.setAttribute("x", x - bbox.width / 2);
        image.setAttribute("y", y - bbox.height / 2);

        // Rotate the image a random number of degrees between 0 and 359 around its center point
        var angle = Math.floor(Math.random() * 360);
        var cx = x;
        var cy = y;
        image.setAttribute(
          "transform",
          "rotate(" + angle + " " + cx + " " + cy + ")"
        );
      });

      // Add clicked path to arrays; push to history
      blizzardArray.push(this.id);
      clickedPathsBlizzardsPortals.push(this.id);
      history.push({ type: 'addBlizzard', pathId: this.id });

       // Check if size of blizzardArray is greater than or equal to totalBlizzards
       if (blizzardArray.length >= totalBlizzards) {
         // Remove existing event listeners from elements in paths array
         paths.forEach(function (path) {
           path.removeEventListener("mouseover", mouseoverHandler);
           path.removeEventListener("mouseout", mouseoutHandler);
           path.removeEventListener("click", clickHandler);
         });
     	       document.getElementById("stopButton").innerHTML = "Stop Editing";
		// Set the regular background color to white
		document.getElementById("stopButton").style.backgroundColor = "white";
		// Set the hover background color to white
		var styleElement = document.createElement("style");
		styleElement.id = "stopButtonHoverStyle";
		styleElement.textContent = "#stopButton:hover { background-color: white !important; }";
		document.head.appendChild(styleElement);

	       generateMap();
	       return;
       }

       // Execute generateMap function
       generateMap();
    }
  };

  // Add event listeners to elements in paths array
  paths.forEach(function (path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
    path.addEventListener("click", clickHandler);
  });
}
  
function button_StopEditing() {
  stopEditing();
}

function button_Undo() {
  undo();
}
	
function button_AddBlizzards() {
  addBlizzards();
}

function button_AddPortals() {
  addPortals();
}
	
function eraser() {
  // Immediately return if the size of the clickedPathsBlizzardsPortals array is empty
  if (clickedPathsBlizzardsPortals.length === 0) {
    return;
  }
  let shouldReturn = false;
  document.getElementById("stopButton").innerHTML = "Stop Erasing";
	// Set the regular background color to green
	document.getElementById("stopButton").style.backgroundColor = "#4caf50";
	// Set the hover background color to dark green
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: #3e8e41 !important; }";
	document.head.appendChild(styleElement);

  const blizzardButtonClick = function () {
    shouldReturn = true;
  };
  const portalButtonClick = function () {
    shouldReturn = true;
  };
  const eraserButtonClick = function () {
    shouldReturn = true;
  };
  const stopButtonClick = function () {
    shouldReturn = true;
  };
	
  document.getElementById("blizzardButton").addEventListener("click", blizzardButtonClick);
  document.getElementById("portalButton").addEventListener("click", portalButtonClick);
  document.getElementById("eraserButton").addEventListener("click", eraserButtonClick);
  document.getElementById("stopButton").addEventListener("click", stopButtonClick);

	// Define mouseover, mouseout, and click event handlers
	const mouseoverHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Change stroke color to #ff1111 and stroke width to 4
	    this.style.setProperty("stroke", "#ff1111", "important");
	    this.style.setProperty("stroke-width", "4", "important");
	  }
	};

	const mouseoutHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (clickedPathsBlizzardsPortals.includes(this.id)) {
	      // Reset stroke color
	      this.style.setProperty("fill", "transparent", "important");
	  }
	};
  const clickHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is in clickedPathsBlizzardsPortals array
    if (clickedPathsBlizzardsPortals.includes(this.id)) {
      // Remove clicked path from clickedPathsBlizzardsPortals array
      clickedPathsBlizzardsPortals = clickedPathsBlizzardsPortals.filter(
        (path) => path !== this.id
      );

      // Check if path is in blizzardArray
      if (blizzardArray.includes(this.id)) {
        // Remove clicked path from blizzardArray; push to history
        blizzardArray = blizzardArray.filter((path) => path !== this.id);
	history.push({ type: 'eraseBlizzard', pathId: this.id });

        // Store the value of this.id in a variable
        var clickedPathId = this.id;

        // Remove blizzard image overlay from clicked path
        var images = svgElement.querySelectorAll("image");
        images.forEach(function (image) {
          // Check if the data-path-id attribute of the image matches the id of the clicked path
          if (image.getAttribute("data-path-id") === clickedPathId) {
            // Remove the image
            image.remove();
          }
        });

      // Check if path is in portalArray
      if (portalArray.includes(this.id)) {
        // Remove clicked path from portalArray; push to history
        portalArray = portalArray.filter((path) => path !== this.id);
	history.push({ type: 'erasePortal', pathId: this.id });

        // Store the value of this.id in a variable
        var clickedPathId = this.id;

        // Remove portal image overlay from clicked path
        var images = svgElement.querySelectorAll("image");
        images.forEach(function (image) {
          // Check if the data-path-id attribute of the image matches the id of the clicked path
          if (image.getAttribute("data-path-id") === clickedPathId) {
            // Remove the image
            image.remove();
          }
        });
      }

      // Call generateMap function
      generateMap();

      // Check if clickedPathsBlizzardsPortals array is empty
      if (clickedPathsBlizzardsPortals.length === 0) {
	document.getElementById("stopButton").innerHTML = "Stop Editing";
	// Set the regular background color to white
	document.getElementById("stopButton").style.backgroundColor = "white";
	// Set the hover background color to white
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: white !important; }";
	document.head.appendChild(styleElement);
        return;
      }
    }
  };

  // Add event listeners to elements in paths array
  paths.forEach(function (path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
    path.addEventListener("click", clickHandler);
  });
}
}

function addBlizzards_pathID(pathID) {
  // Find the path element with the specified pathID
  let path = Array.from(paths).find((path) => path.getAttribute("id") === pathID);

  // Create an image element and set its attributes
  var image = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "image"
  );
  image.setAttributeNS(
    "http://www.w3.org/1999/xlink",
    "href",
    "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/snowflake.png"
  );

  // Set a custom attribute to store the id of the clicked path
  image.setAttribute("data-path-id", pathID);

  // Store the value of pathID in a variable
  var clickedPathId = pathID;

  // Find matching row in CSV data
  var tableRow = tableData.find(function (row) {
    return row["Territory"] === clickedPathId;
  });

  // Get coordinates from CSV data
  var x = tableRow["Pixel Pair 1"];
  var y = tableRow["Pixel Pair 2"];

  // Set pointer-events attribute of the image element to none
  image.setAttribute("pointer-events", "none");

  // Append the image to the SVG
  svgElement.appendChild(image);

  // Add an event listener to the image element to update its x and y attributes after it has been loaded
  image.addEventListener("load", function () {
    // Get the bounding box of the image element
    var bbox = image.getBBox();

    // Update the x and y attributes of the image element to center it over the clicked area
    image.setAttribute("x", x - bbox.width / 2);
    image.setAttribute("y", y - bbox.height / 2);

    // Rotate the image a random number of degrees between 0 and 359 around its center point
    var angle = Math.floor(Math.random() * 360);
    var cx = x;
    var cy = y;
    image.setAttribute(
      "transform",
      "rotate(" + angle + " " + cx + " " + cy + ")"
    );
  });

   // Add clicked path to arrays; push to history
   blizzardArray.push(pathID);
   clickedPathsBlizzardsPortals.push(pathID);

   // Execute generateMap function
   generateMap();
   return;
}
  
function addPortals_pathID(pathID) {
  // Find the path element with the specified pathID
  let path = Array.from(paths).find((path) => path.getAttribute("id") === pathID);

  // Create an image element and set its attributes
  var image = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "image"
  );
  image.setAttributeNS(
    "http://www.w3.org/1999/xlink",
    "href",
    "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/portal.png"
  );

  // Set a custom attribute to store the id of the clicked path
  image.setAttribute("data-path-id", pathID);

  // Store the value of pathID in a variable
  var clickedPathId = pathID;

  // Find matching row in CSV data
  var tableRow = tableData.find(function (row) {
    return row["Territory"] === clickedPathId;
  });

  // Get coordinates from CSV data
  var x = tableRow["Pixel Pair 1"];
  var y = tableRow["Pixel Pair 2"];

  // Set pointer-events attribute of the image element to none
  image.setAttribute("pointer-events", "none");

  // Append the image to the SVG
  svgElement.appendChild(image);

  // Add an event listener to the image element to update its x and y attributes after it has been loaded
  image.addEventListener("load", function () {
    // Get the bounding box of the image element
    var bbox = image.getBBox();

    // Update the x and y attributes of the image element to center it over the clicked area
    image.setAttribute("x", x - bbox.width / 2);
    image.setAttribute("y", y - bbox.height / 2);

    // Rotate the image a random number of degrees between 0 and 359 around its center point
    var angle = Math.floor(Math.random() * 360);
    var cx = x;
    var cy = y;
    image.setAttribute(
      "transform",
      "rotate(" + angle + " " + cx + " " + cy + ")"
    );
  });

   // Add clicked path to arrays; push to history
   portalArray.push(pathID);
   clickedPathsBlizzardsPortals.push(pathID);

   // Execute generateMap function
   generateMap();
   return;
}
	
// Update button text on page load
updateButtonText();

function updateButtonText() {
    // Update "Add Blizzards" button text
    if (totalBlizzards - blizzardArray.length <= 0) {
        document.getElementById("blizzardButton").innerHTML = "Added all Blizzards";
    } else {
        document.getElementById("blizzardButton").innerHTML = "Add Blizzards (" + (totalBlizzards - blizzardArray.length) + " left)";
    }

    // Update "Add Portals" button text
    if (totalPortals - portalArray.length <= 0) {
        document.getElementById("portalButton").innerHTML = "Added all Portals";
    } else {
        document.getElementById("portalButton").innerHTML = "Add Portals (" + (totalPortals - portalArray.length) + " left)";
    }
}

// Create an array to store the history of actions
let history = [];

// Add an event listener for the keydown event to the document object
document.addEventListener('keydown', function(event) {
  // Check if the ctrlKey property is true and if the key property is equal to 'z'
  if (event.ctrlKey && event.key === 'z') {
    // Call the undo function
    undo();
  }
});

function undo() {
  // Check if the history array is not empty
  if (history.length > 0) {
    // Get the last action from the history array
    let lastAction = history.pop();

    // Check the type of the last action
    if (lastAction.type === 'addBlizzard') {
      // Remove the last blizzard from the blizzardArray
      blizzardArray.pop();

      // Remove the last blizzard image from the map
      let images = svgElement.querySelectorAll('image');
      images.forEach(function(image) {
        // Check if the data-path-id attribute of the image matches the id of the last blizzard
        if (image.getAttribute('data-path-id') === lastAction.pathId) {
          // Remove the image
          image.remove();
        }
      });

      // Remove the id of the undone path from the clickedPathsBlizzardsPortals array
      let index = clickedPathsBlizzardsPortals.indexOf(lastAction.pathId);
      if (index !== -1) {
        clickedPathsBlizzardsPortals.splice(index, 1);
      }
	  generateMap();
    } else if (lastAction.type === 'addPortal') {
      // Remove the last portal from the portalArray
      portalArray.pop();

      // Remove the last portal image from the map
      let images = svgElement.querySelectorAll('image');
      images.forEach(function(image) {
        // Check if the data-path-id attribute of the image matches the id of the last portal
        if (image.getAttribute('data-path-id') === lastAction.pathId) {
          // Remove the image
          image.remove();
        }
      });

      // Remove the id of the undone path from the clickedPathsBlizzardsPortals array
      let index = clickedPathsBlizzardsPortals.indexOf(lastAction.pathId);
      if (index !== -1) {
        clickedPathsBlizzardsPortals.splice(index, 1);
      }
	  generateMap();
    } else if (lastAction.type === 'eraseBlizzard') {
	  addBlizzards_pathID(lastAction.pathId);
    } else if (lastAction.type === 'erasePortal') {
	  addPortals_pathID(lastAction.pathId);
    }
  }
}
</script>
</body>
</html>
