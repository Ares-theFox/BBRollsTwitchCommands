<!DOCTYPE html>
<html>
  <head>
    <title>United States</title>
    <style>
      #map,
      #range {
        position: absolute;
      }
      #range {
        z-index: 1;
      }
      header {
        font-size: 35px;
        font-weight: bold;
      }
      header img {
        vertical-align: bottom;
      }
      #fontSizeInput {
        width: 35px;
      }
    </style>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  </head>
  <body>
    <header>
	United States Dynamic Zombie Pathing
	<img src="" />
        <span id="invalidText" style="color: red; font-style: italic; font-size: 20px;"></span>
    </header>
<div>
  <button id="zoomInButton"><i class="fas fa-search-plus"></i></button>
  <button id="blizzardButton" onclick="button_AddBlizzards()">Add Blizzards</button>
  <button id="eraserButton" onclick="eraser()">Eraser</button>
  <label for="fontSizeInput">Font Size:</label>
  <input type="number" id="fontSizeInput" name="fontSizeInput" value="30" min="1" max="100">
  <button id="stopButton" onclick="button_StopEditing()">Stop Editing</button>
</div>
<div>
  <button id="zoomOutButton"><i class="fas fa-search-minus"></i></button>
  <button id="portalButton" onclick="button_AddPortals()">Add Portals</button>
  <button id="undoButton" onclick="button_Undo()">Undo</button>
  <button id="resetButton">Reset Map</button>
  <a href="https://ares-thefox.github.io/Risk-Dynamic-Disconnection-Maps" target="_blank">
    <button id="mapDirectoryButton">Map Directory</button>
  </a>
</div>
	<style>
	/* Add some basic styles to the button */
	button {
	font-size: 16px;
	padding: 8px 16px;
	border: none;
	cursor: pointer;
	}

	#blizzardButton {
	width: 180px;
	text-align: center;
	background-color: white;
	color: black;
	}

	#blizzardButton:hover {
	background-color: grey;
	}

	#portalButton {
	width: 180px;
	text-align: center;
	background-color: aqua;
	color: black;
	}

	#portalButton:hover {
	background-color: navy;
	color: white;
	}

	#eraserButton {
	width: 80px;
	text-align: center;
	background-color: #dd9d90;
	color: black;
	}

	#eraserButton:hover {
	background-color: #c89790;
	}
		
	#stopButton {
	background-color: white;
	color: white;
	}

	#stopButton:hover {
	background-color: white;
	}
		
	#undoButton {
	width: 80px;
	text-align: center;
	background-color: #d8482e;
	color: black;
	}

	#undoButton:hover {
	background-color: #c13e27;
	}

	#resetButton {
	width: 112px;
	text-align: center;
	background-color: grey;
	color: white;
	}

	#resetButton:hover {
	background-color: black;
	color: white;
	}

	#mapDirectoryButton {
	background-color: white;
	color: black;
	}

	#mapDirectoryButton:hover {
	background-color: grey;
	}
		
	#zoomInButton:hover {
	background-color: #ababab;
	}
		
	#zoomOutButton:hover {
	background-color: #ababab;
	}
	</style>
	  
    <img
      id="map"
      src="https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/United%20States.PNG"
      alt="United States"
    />

<!-- Add a new SVG element with a unique id -->
<svg id="map-svg" style="pointer-events: none;"></svg>

<!-- Add JavaScript code to set the dimensions of the SVG element -->
<script>
  // Get the img element containing the PNG image
  const imgElement = document.querySelector("#map");

  // Get the dimensions of the PNG image
  const imgWidth = imgElement.naturalWidth;
  const imgHeight = imgElement.naturalHeight;

  // Get the SVG element
  const mapSvgElement = document.querySelector("#map-svg");

  // Set the dimensions of the SVG element to match the PNG image
  mapSvgElement.setAttribute("width", imgWidth);
  mapSvgElement.setAttribute("height", imgHeight);
</script>

    <div id="range"></div>
	  
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script>
<script>
  let zoom = 1;
  document.getElementById("zoomInButton").addEventListener("click", function () {
    zoom += 0.1;
    document.body.style.zoom = zoom;
  });
  document.getElementById("zoomOutButton").addEventListener("click", function () {
    zoom -= 0.1;
    document.body.style.zoom = zoom;
  });
	
  document.getElementById("resetButton").addEventListener("click", function () {
    location.reload();
  });

var images = [
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox1.PNG",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox2.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox3.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox4.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox5.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox6.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox7.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox8.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox9.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox10.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox11.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox12.png"
];

// Preload the blizzard pattern
var blizzardPatternImage = new Image();
blizzardPatternImage.src = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/United%20States%20blizzard%20pattern.png";

window.onload = function() {
  var img = document.querySelector("header img");
  var randomIndex = Math.floor(Math.random() * images.length);
  img.src = images[randomIndex];
};

// Define global variables
console.log("432")

	// Define map-specific items
	var ZombieConnections = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Zombie-Pathing/main/United%20States%20Zombie%20Pathing.csv"
	var TerritoryLocations = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Zombie-Pathing/main/United%20States%20Pixel%20Locations.csv"
	var SVG = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/United%20States%20Paths.svg"
	var BlizzardPattern = blizzardPatternImage.src;
	// Remember to change the img src, blizzard pattern, and the alt title!!!!!!!!

	var totalBlizzards = 3
	var totalPortals = 5
	
	let blizzardArray = []
	let portalArray = []
	let clickedPathsBlizzardsPortals = []
	
	// Define connections tableData
	let tableData;
	let tableDataClone;
	Papa.parse(
	  ZombieConnections,
	  {
	    download: true,
	    header: true,
	    complete: function (results) {
	      // Assign parsed data to tableData
	      tableData = results.data;
	      // Remove zero-width space character from tableData
	      for (let i = 0; i < tableData.length; i++) {
		for (let key in tableData[i]) {
		  if (tableData[i].hasOwnProperty(key)) {
		    tableData[i][key] = tableData[i][key].replace(/\u200B/g, "");
		  }
		}
	      }
	      // Create a deep copy of tableData
	      tableDataClone = JSON.parse(JSON.stringify(tableData));
	    },
	  }
	);
	
	// Define color dictionaries 
	const colorDictionary = {
	  1: "#eb3337",
	  2: "#fd8238",
	  3: "#fdf12c",
	  4: "#2ed14f",
	  5: "#2ca9f1",
	  6: "#4a51cc",
	  7: "#b948ba",
	  8: "#8b2c32",
	  9: "#5f5f5f",
	 10: "#377a46",
	 11: "#460055",
	 12: "#161616"
	};
	const colorDarktionary = {
	 1: "#761a1c",
	 2: "#7f411c",
	 3: "#7f7916",
	 4: "#176928",
	 5: "#165579",
	 6: "#252966",
	 7: "#5d245d",
	 8: "#461619",
	 9: "#303030",
	10: "#1c3d23",
	11: "#23002b",
	12: "#000000"
	};

      const colors = {
        "Primary (1)": "black",
        "Secondary (2)": "#ff0000",
        "Tertiary (3)": "white",
        "Quaternary (4)": "#00ff00",
        "Quinary (5)": "#00ffff",
        "Senary (6)": "yellow",
      };
	
	// Define csvData as a global variable
	var csvData;
	
	// Define a counter variable to keep track of the number of requests that have completed
	var requestsCompleted = 0;
	
	// Define a function to call when a request has completed
	function onRequestComplete() {
	  requestsCompleted++;
	  if (requestsCompleted === 2) {
	    // Both requests have completed, so call the generateMap function
	    generateMap();
	  }
	}

	// Load the CSV data
	Papa.parse(
	  TerritoryLocations,
	  {
	    download: true,
	    header: true,
	    complete: function (results) {
	      // Assign the parsed data to the global csvData variable
	      csvData = results.data;
	      // Call the onRequestComplete function to indicate that this request has completed
	      onRequestComplete();
	    }
	  }
	);
	
// End of global variables

	// Load the SVG
	let paths;
	let svgElement;
	var xhr = new XMLHttpRequest();
	xhr.open(
	  "GET",
	  SVG
	);
	xhr.onload = function () {
	  if (xhr.status === 200) {
	    var svg = xhr.responseText;
	    var rangeElement = document.getElementById("range");
	    rangeElement.innerHTML = svg;
	    svgElement = rangeElement.querySelector("svg");
	    paths = svgElement.querySelectorAll("path");
	    paths.forEach(function (path) {
	      path.setAttribute("fill", "transparent");
	      path.setAttribute("stroke-opacity", "0");
	    });
	    // Call the onRequestComplete function to indicate that this request has completed
	    onRequestComplete();
	  }
	};
	xhr.send();

// Stop editing
function stopEditing() {
	document.getElementById("stopButton").innerHTML = "Stop Editing";
	// Set the regular background color to white
	document.getElementById("stopButton").style.backgroundColor = "white";
	// Set the hover background color to white
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: white !important; }";
	document.head.appendChild(styleElement);
	return;
}
	
// Generate the map
function generateMap() {
  // Update buttons
  updateButtonText();
  // Reset tableData to its original values
  tableData = JSON.parse(JSON.stringify(tableDataClone));
  // Remove existing text elements
  svgElement.querySelectorAll("text").forEach((text) => text.remove());
  // Remove everything contained in the blizzard array
	// Find rows in table data where column A matches values in blizzardArray
	const rows = tableData.filter((row) => blizzardArray.includes(row["Territory"]));

	// Remove everything in column B for those rows
	rows.forEach((row) => {
	  row["Connections"] = "";
	});

	// Remove all instances of values in blizzardArray from column B
	tableData.forEach((row) => {
	  if (row["Connections"]) {
	    // Split the value in column B into an array of values
	    let values = row["Connections"].split(",");
	    // Filter out any values that are included in the blizzardArray
	    values = values.filter((value) => !blizzardArray.includes(value));
	    // Join the remaining values back into a string and update the value in column B
	    row["Connections"] = values.join(",");
	  }
	});
  // Add everything contained in the portal array
	// Iterate over tableData
	tableData.forEach((row) => {
	  // Check if value in column A matches a value in portalArray
	  if (portalArray.includes(row["Territory"])) {
	    // Add contents of portalArray to column B
	    row["Connections"] = [
	      ...new Set([
		...(row["Connections"] ? row["Connections"].split(",") : []),
		...portalArray,
	      ]),
	    ]
	      .filter((value) => value !== row["Territory"])
	      .join(",");
	  }
	});
  // Create a dictionary to map territory names to pixel locations
  const locationDict = {};
  const extraLocationDict = {};
  csvData.forEach((row) => {
    locationDict[row["Range"]] = [parseInt(row["Pixel Pair 1"]), parseInt(row["Pixel Pair 2"])];
    if (row["Extra 1"] && row["Extra 2"] && row["Connection"]) {
      extraLocationDict[[row["Range"], row["Connection"]]] = [parseInt(row["Extra 1"]), parseInt(row["Extra 2"])];
    }
  });

  // Get the SVG element
  const mapSvgElement = document.querySelector("#map-svg");

  // Function to calculate the points of an arrowhead
  function arrowhead(start, end) {
    const angle = Math.atan2(start[1] - end[1], start[0] - end[0]);
    const x1 = end[0] + 10 * Math.cos(angle + Math.PI / 6);
    const y1 = end[1] + 10 * Math.sin(angle + Math.PI / 6);
    const x2 = end[0] + 10 * Math.cos(angle - Math.PI / 6);
    const y2 = end[1] + 10 * Math.sin(angle - Math.PI / 6);
    return [[x1, y1], end, [x2, y2]];
  }

  // Function to calculate a point offset from the start or end point
  function offsetPoint(start, end, offset) {
    const angle = Math.atan2(start[1] - end[1], start[0] - end[0]);
    const x = end[0] + offset * Math.cos(angle);
    const y = end[1] + offset * Math.sin(angle);
    return [x, y];
  }

  // Function to calculate a point offset perpendicular to the line between two points
  function perpendicularOffsetPoint(point, angle, offset) {
    const x = point[0] + offset * Math.cos(angle);
    const y = point[1] + offset * Math.sin(angle);
    return [x, y];
  }

  // Count the number of lines between each pair of nodes
  const lineCounts = {};
  tableData.forEach((row) => {
	  // Check if the "Territory" column of the current row is not empty
	    if (row["Territory"]) {
    const startLocation = locationDict[row["Territory"]];
    row["Connections"].split(",").forEach((col, i) => {
	    console.log("Processing connection:", col)
      if (i < Object.keys(colors).length) {
        const endLocation = locationDict[col];
        const pair = [row["Territory"], col].sort();
        if (!lineCounts[pair]) {
          lineCounts[pair] = 0;
        }
        lineCounts[pair]++;
      }
    });
	    }
  })
		console.log("tableData:", tableData);
		console.log("csvData:", csvData);
		console.log("locationDict:", locationDict);
		console.log("extraLocationDict:", extraLocationDict);
		console.log("lineCounts:", lineCounts);
		console.log("mapSvgElement:", mapSvgElement);
		console.log("Number of lines in SVG:", mapSvgElement.querySelectorAll("line").length);

}
	
function debounce(func, wait) {
  let timeout;
  return function() {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, arguments), wait);
  };
}

const debouncedGenerateMap = debounce(generateMap, 500);

function addBlizzards() {
  let shouldReturn = false;
  document.getElementById("stopButton").innerHTML = "Stop Adding Blizzards";
	// Set the regular background color to green
	document.getElementById("stopButton").style.backgroundColor = "#4caf50";
	// Set the hover background color to dark green
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: #3e8e41 !important; }";
	document.head.appendChild(styleElement);

  const blizzardButtonClick = function () {
    shouldReturn = true;
  };
  const portalButtonClick = function () {
    shouldReturn = true;
  };
  const eraserButtonClick = function () {
    shouldReturn = true;
  };
  const stopButtonClick = function () {
    shouldReturn = true;
  };
	
  document.getElementById("blizzardButton").addEventListener("click", blizzardButtonClick);
  document.getElementById("portalButton").addEventListener("click", portalButtonClick);
  document.getElementById("eraserButton").addEventListener("click", eraserButtonClick);
  document.getElementById("stopButton").addEventListener("click", stopButtonClick);

  // Check if size of blizzardArray is greater than or equal to totalBlizzards
  if (blizzardArray.length >= totalBlizzards) {
    // Return early from the function
    return;
  }
	// Define mouseover, mouseout, and click event handlers
	const mouseoverHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Change stroke color to white and stroke width to 3
	    this.style.setProperty("stroke", "white", "important");
	    this.style.setProperty("stroke-width", "3", "important");
	  }
	};
	const mouseoutHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (!clickedPathsBlizzardsPortals.includes(this.id)) {
		this.style.removeProperty("stroke");
		this.style.removeProperty("stroke-width");
	  }
	};
  const clickHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is NOT in clickedPathsBlizzardsPortals array
    if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	// Create a clipPath element and set its id
	var clipPath = document.createElementNS(
	  "http://www.w3.org/2000/svg",
	  "clipPath"
	);
	clipPath.setAttribute("id", "clip-" + this.id);

	// Clone the clicked path and append it to the clipPath
	var clonedPath = this.cloneNode(true);
	clipPath.appendChild(clonedPath);

	// Append the clipPath to the defs element
	var defs =
	  svgElement.querySelector("defs") ||
	  svgElement.insertBefore(
	    document.createElementNS("http://www.w3.org/2000/svg", "defs"),
	    svgElement.firstChild
	  );
	defs.appendChild(clipPath);

	// Create an image element and set its attributes
	var image = document.createElementNS(
	  "http://www.w3.org/2000/svg",
	  "image"
	);
	image.setAttributeNS(
	  "http://www.w3.org/1999/xlink",
	  "href",
	  BlizzardPattern
	);
	image.setAttribute("width", "100%");
	image.setAttribute("height", "100%");
	image.setAttribute("clip-path", "url(#clip-" + this.id + ")");
	image.setAttribute("pointer-events", "none");

	// Append the image to the SVG
	svgElement.appendChild(image);

	// Move the image behind the path element
	svgElement.insertBefore(image, svgElement.firstChild);
	    
    // Add clicked path to arrays; push to history
    blizzardArray.push(this.id);
    clickedPathsBlizzardsPortals.push(this.id);
    history.push({ type: 'addBlizzard', pathId: this.id });
	    
    // Change the fill of the clicked path to transparent
    this.style.setProperty("fill", "transparent", "important");

    // Change stroke color and stroke width
    this.style.setProperty("stroke", "white", "important");
    this.style.setProperty("stroke-width", "1", "important");
	    
    // Check if size of blizzardArray is greater than or equal to totalBlizzards
    if (blizzardArray.length >= totalBlizzards) {
      // Remove existing event listeners from elements in paths array
      paths.forEach(function (path) {
        path.removeEventListener("mouseover", mouseoverHandler);
        path.removeEventListener("mouseout", mouseoutHandler);
        path.removeEventListener("click", clickHandler);
      });
      document.getElementById("stopButton").innerHTML = "Stop Editing";
	// Set the regular background color to white
	document.getElementById("stopButton").style.backgroundColor = "white";
	// Set the hover background color to white
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: white !important; }";
	document.head.appendChild(styleElement);

      generateMap();
      return;
    }

    // Execute generateMap function
    generateMap();
    }
    };

  // Add event listeners to elements in paths array
  paths.forEach(function (path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
    path.addEventListener("click", clickHandler);
  });
}
	
function addBlizzards_pathID(pathID) {
  // Find the path element with the specified pathID
  let path = Array.from(paths).find((path) => path.getAttribute("id") === pathID);

  // Create a clipPath element and set its id
  var clipPath = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "clipPath"
  );
  clipPath.setAttribute("id", "clip-" + pathID);

  // Clone the clicked path and append it to the clipPath
  var clonedPath = path.cloneNode(true);
  clipPath.appendChild(clonedPath);

  // Append the clipPath to the defs element
  var defs =
    svgElement.querySelector("defs") ||
    svgElement.insertBefore(
      document.createElementNS("http://www.w3.org/2000/svg", "defs"),
      svgElement.firstChild
    );
  defs.appendChild(clipPath);

  // Create an image element and set its attributes
  var image = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "image"
  );
  image.setAttributeNS(
    "http://www.w3.org/1999/xlink",
    "href",
    BlizzardPattern
  );
  image.setAttribute("width", "100%");
  image.setAttribute("height", "100%");
  image.setAttribute("clip-path", "url(#clip-" + pathID + ")");
  image.setAttribute("pointer-events", "none");

  // Append the image to the SVG
  svgElement.appendChild(image);

  // Move the image behind the path element
  svgElement.insertBefore(image, svgElement.firstChild);

  // Add clicked path to arrays; push to history
  blizzardArray.push(pathID);
  clickedPathsBlizzardsPortals.push(pathID);
  
  // Change the fill of the clicked path to transparent
  path.style.setProperty("fill", "transparent", "important");

  // Change stroke color and stroke width
  path.style.setProperty("stroke", "white", "important");
  path.style.setProperty("stroke-width", "1", "important");

   // Execute generateMap function
   generateMap();
   return;
}

function addPortals() {
	return
}

function button_StopEditing() {
  stopEditing();
}

function button_Undo() {
  undo();
}
	
function button_AddBlizzards() {
  addBlizzards();
}

function button_AddPortals() {
  addPortals();
}
	
function eraser() {
  // Immediately return if the size of the clickedPathsBlizzardsPortals array is empty
  if (clickedPathsBlizzardsPortals.length === 0) {
    return;
  }
  let shouldReturn = false;
  document.getElementById("stopButton").innerHTML = "Stop Erasing";
	// Set the regular background color to green
	document.getElementById("stopButton").style.backgroundColor = "#4caf50";
	// Set the hover background color to dark green
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: #3e8e41 !important; }";
	document.head.appendChild(styleElement);

  const blizzardButtonClick = function () {
    shouldReturn = true;
  };
  const portalButtonClick = function () {
    shouldReturn = true;
  };
  const eraserButtonClick = function () {
    shouldReturn = true;
  };
  const stopButtonClick = function () {
    shouldReturn = true;
  };
	
  document.getElementById("blizzardButton").addEventListener("click", blizzardButtonClick);
  document.getElementById("portalButton").addEventListener("click", portalButtonClick);
  document.getElementById("eraserButton").addEventListener("click", eraserButtonClick);
  document.getElementById("stopButton").addEventListener("click", stopButtonClick);

	// Define mouseover, mouseout, and click event handlers
	const mouseoverHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Change stroke color to #ff1111 and stroke width to 4
	    this.style.setProperty("stroke", "#ff1111", "important");
	    this.style.setProperty("stroke-width", "4", "important");
	  }
	};

	const mouseoutHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (clickedPathsBlizzardsPortals.includes(this.id)) {
	    if (blizzardArray.includes(this.id)) {
	      // Change stroke color to white and stroke width to 3
	      this.style.setProperty("stroke", "white", "important");
	      this.style.setProperty("stroke-width", "1", "important");
	    } else if (portalArray.includes(this.id)) {
	      // Reset stroke color and width according to the color darktionary
	      let value = tableData.find(row => row['A'] === this.id)['O'];
	      if (value >= 12) {
		value = 12;
	      }
	      let border_color = colorDarktionary[value];
	      this.style.setProperty("stroke", border_color, "important");
	      this.style.setProperty("stroke-width", "2", "important");
	    }
	  }
	};
  const clickHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is in clickedPathsBlizzardsPortals array
    if (clickedPathsBlizzardsPortals.includes(this.id)) {
      // Remove clicked path from clickedPathsBlizzardsPortals array
      clickedPathsBlizzardsPortals = clickedPathsBlizzardsPortals.filter(
        (path) => path !== this.id
      );

      // Check if path is in blizzardArray
      if (blizzardArray.includes(this.id)) {
        // Remove clicked path from blizzardArray; push to history
        blizzardArray = blizzardArray.filter((path) => path !== this.id);
	history.push({ type: 'eraseBlizzard', pathId: this.id });

        // Remove blizzard fill from clicked path
        var clipPathId = "blizzard-clip-" + this.id;
        var clipPath = document.getElementById(clipPathId);
        if (clipPath) {
          clipPath.remove();
        }
      }

      // Check if path is in portalArray
      if (portalArray.includes(this.id)) {
        // Remove clicked path from portalArray; push to history
        portalArray = portalArray.filter((path) => path !== this.id);
	history.push({ type: 'erasePortal', pathId: this.id });

        // Store the value of this.id in a variable
        var clickedPathId = this.id;

        // Remove portal image overlay from clicked path
        var images = svgElement.querySelectorAll("image");
        images.forEach(function (image) {
          // Check if the data-path-id attribute of the image matches the id of the clicked path
          if (image.getAttribute("data-path-id") === clickedPathId) {
            // Remove the image
            image.remove();
          }
        });
      }

      // Call generateMap function
      generateMap();

      // Check if clickedPathsBlizzardsPortals array is empty
      if (clickedPathsBlizzardsPortals.length === 0) {
	document.getElementById("stopButton").innerHTML = "Stop Editing";
	// Set the regular background color to white
	document.getElementById("stopButton").style.backgroundColor = "white";
	// Set the hover background color to white
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: white !important; }";
	document.head.appendChild(styleElement);
        return;
      }
    }
  };

  // Add event listeners to elements in paths array
  paths.forEach(function (path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
    path.addEventListener("click", clickHandler);
  });
}

function addPortals_pathID(pathID) {
	return
}
	
// Update button text on page load
updateButtonText();

function updateButtonText() {
    // Update "Add Blizzards" button text
    if (totalBlizzards - blizzardArray.length <= 0) {
        document.getElementById("blizzardButton").innerHTML = "Added all Blizzards";
    } else {
        document.getElementById("blizzardButton").innerHTML = "Add Blizzards (" + (totalBlizzards - blizzardArray.length) + " left)";
    }

    // Update "Add Portals" button text
    if (totalPortals - portalArray.length <= 0) {
        document.getElementById("portalButton").innerHTML = "Added all Portals";
    } else {
        document.getElementById("portalButton").innerHTML = "Add Portals (" + (totalPortals - portalArray.length) + " left)";
    }
}

// Create an array to store the history of actions
let history = [];

// Add an event listener for the keydown event to the document object
document.addEventListener('keydown', function(event) {
  // Check if the ctrlKey property is true and if the key property is equal to 'z'
  if (event.ctrlKey && event.key === 'z') {
    // Call the undo function
    undo();
  }
});

function undo() {
  // Check if the history array is not empty
  if (history.length > 0) {
    // Get the last action from the history array
    let lastAction = history.pop();

    // Check the type of the last action
    if (lastAction.type === 'addBlizzard') {
      // Remove the last blizzard from the blizzardArray
      blizzardArray.pop();

      // Remove the last blizzard fill from the map
      let clipPathId = 'blizzard-clip-' + lastAction.pathId;
      let clipPath = document.getElementById(clipPathId);
      if (clipPath) {
        clipPath.remove();
      }

      // Remove the id of the undone path from the clickedPathsBlizzardsPortals array
      let index = clickedPathsBlizzardsPortals.indexOf(lastAction.pathId);
      if (index !== -1) {
        clickedPathsBlizzardsPortals.splice(index, 1);
      }
	  generateMap();
    } else if (lastAction.type === 'addPortal') {
      // Remove the last portal from the portalArray
      portalArray.pop();

      // Remove the last portal image from the map
      let images = svgElement.querySelectorAll('image');
      images.forEach(function(image) {
        // Check if the data-path-id attribute of the image matches the id of the last portal
        if (image.getAttribute('data-path-id') === lastAction.pathId) {
          // Remove the image
          image.remove();
        }
      });

      // Remove the id of the undone path from the clickedPathsBlizzardsPortals array
      let index = clickedPathsBlizzardsPortals.indexOf(lastAction.pathId);
      if (index !== -1) {
        clickedPathsBlizzardsPortals.splice(index, 1);
      }
	  generateMap();
    } else if (lastAction.type === 'eraseBlizzard') {
	  addBlizzards_pathID(lastAction.pathId);
    } else if (lastAction.type === 'erasePortal') {
	  addPortals_pathID(lastAction.pathId);
    }
  }
}
</script>
</body>
</html>
